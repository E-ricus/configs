#!/usr/bin/env bash
# symlinkmanager - Smart dotfiles symlinking with custom targets
# Usage: cd ~/.dotfiles && symlinkmanager link

set -euo pipefail

# Use current working directory
DOTFILES_DIR="$(pwd)"
CONFIG_FILE="$DOTFILES_DIR/symlink.conf"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $*"; }

# Check if config exists
if [ ! -f "$CONFIG_FILE" ]; then
    log_error "symlink.conf not found at $CONFIG_FILE"
    log_info "Make sure you're in your dotfiles directory"
    exit 1
fi

# Create a symlink with backup if exists
safe_symlink() {
    local source="$1"
    local target="$2"
    local is_merge="${3:-false}"
    
    # If target already exists and is a symlink pointing to our source, skip
    if [ -L "$target" ]; then
        local current_link=$(readlink "$target")
        if [ "$current_link" = "$source" ]; then
            return 0  # Already linked correctly
        else
            # Symlink exists but points elsewhere
            if [ "$is_merge" = "true" ]; then
                log_warning "Skipping (existing symlink): $target -> $current_link"
                return 1
            else
                local backup="${target}.backup.$(date +%Y%m%d_%H%M%S)"
                log_warning "Backing up existing symlink: $target -> $backup"
                mv "$target" "$backup"
            fi
        fi
    elif [ -e "$target" ]; then
        # File/directory exists but is not a symlink
        if [ "$is_merge" = "true" ]; then
            log_warning "Skipping (already exists): $target"
            return 1
        else
            local backup="${target}.backup.$(date +%Y%m%d_%H%M%S)"
            log_warning "Backing up existing: $target -> $backup"
            mv "$target" "$backup"
        fi
    fi
    
    # Create parent directory if needed
    mkdir -p "$(dirname "$target")"
    
    # Create symlink
    ln -sf "$source" "$target"
    echo "  → $target"
    return 0
}

# Recursively symlink directory contents
link_directory_contents() {
    local source_dir="$1"
    local target_dir="$2"
    local indent="${3:-  }"
    
    # Ensure target directory exists
    mkdir -p "$target_dir"
    
    # Process all items in source directory
    for item in "$source_dir"/* "$source_dir"/.[!.]* "$source_dir"/..?*; do
        # Skip if glob didn't match anything
        [ -e "$item" ] || continue
        
        local item_name=$(basename "$item")
        local target_path="$target_dir/$item_name"
        
        if [ -d "$item" ]; then
            # It's a directory
            if [ -L "$target_path" ]; then
                # Target is a symlink
                local current_link=$(readlink "$target_path")
                if [ "$current_link" = "$item" ]; then
                    # Already linked correctly, skip
                    continue
                else
                    # Symlink points elsewhere, skip with warning
                    log_warning "Skipping (existing symlink): $target_path -> $current_link"
                    continue
                fi
            elif [ -d "$target_path" ]; then
                # Target directory exists (not a symlink), recurse into it
                link_directory_contents "$item" "$target_path" "    $indent"
            else
                # Target doesn't exist, symlink whole directory
                safe_symlink "$item" "$target_path" "true"
            fi
        else
            # It's a file, try to symlink it (will skip if exists)
            safe_symlink "$item" "$target_path" "true"
        fi
    done
}

# Link packages according to config
link_packages() {
    log_info "Reading configuration from $CONFIG_FILE"
    log_info "Working directory: $DOTFILES_DIR"
    echo
    
    while IFS= read -r line; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Parse: package -> target
        if [[ "$line" =~ ^([^-]+)[[:space:]]*-\>[[:space:]]*(.+)$ ]]; then
            local package="${BASH_REMATCH[1]// /}"
            local target="${BASH_REMATCH[2]// /}"
            
            # Expand ~ to home directory
            target="${target/#\~/$HOME}"
            
            local source_dir="$DOTFILES_DIR/$package"
            
            # Check if package directory exists
            if [ ! -d "$source_dir" ]; then
                log_warning "Package '$package' not found at $source_dir, skipping"
                continue
            fi
            
            log_info "Linking $package -> $target"
            
            # Check if target exists
            if [ -d "$target" ] && [ ! -L "$target" ]; then
                # Target directory exists and is not a symlink - merge contents
                log_info "Target exists, merging contents..."
                link_directory_contents "$source_dir" "$target"
            elif [ -L "$target" ]; then
                # Target is a symlink
                local current_link=$(readlink "$target")
                if [ "$current_link" = "$source_dir" ]; then
                    log_success "Already linked correctly"
                else
                    log_warning "Target is symlink to different location, replacing..."
                    rm "$target"
                    safe_symlink "$source_dir" "$target"
                fi
            else
                # Target doesn't exist - symlink whole directory
                safe_symlink "$source_dir" "$target"
            fi
            
            log_success "$package linked successfully"
            echo
        else
            log_warning "Invalid line format: $line"
        fi
    done < "$CONFIG_FILE"
}

# Remove symlinks
unlink_packages() {
    log_info "Reading configuration from $CONFIG_FILE"
    echo
    
    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        if [[ "$line" =~ ^([^-]+)[[:space:]]*-\>[[:space:]]*(.+)$ ]]; then
            local package="${BASH_REMATCH[1]// /}"
            local target="${BASH_REMATCH[2]// /}"
            target="${target/#\~/$HOME}"
            
            local source_dir="$DOTFILES_DIR/$package"
            
            log_info "Unlinking $package from $target"
            
            if [ -L "$target" ]; then
                local link_target=$(readlink "$target")
                if [[ "$link_target" == "$source_dir"* ]]; then
                    rm "$target"
                    log_success "Removed symlink: $target"
                else
                    log_warning "Symlink points elsewhere: $target -> $link_target"
                fi
            elif [ -d "$target" ]; then
                # Directory exists, check for symlinks inside
                unlink_directory_contents "$source_dir" "$target"
            else
                log_info "Target doesn't exist: $target"
            fi
            
            echo
        fi
    done < "$CONFIG_FILE"
}

# Recursively remove symlinks from directory
unlink_directory_contents() {
    local source_dir="$1"
    local target_dir="$2"
    
    [ -d "$target_dir" ] || return
    
    for item in "$source_dir"/* "$source_dir"/.[!.]* "$source_dir"/..?*; do
        [ -e "$item" ] || continue
        
        local item_name=$(basename "$item")
        local target_path="$target_dir/$item_name"
        
        if [ -L "$target_path" ]; then
            local link_target=$(readlink "$target_path")
            if [ "$link_target" = "$item" ]; then
                rm "$target_path"
                echo "  Removed: $target_path"
            fi
        elif [ -d "$item" ] && [ -d "$target_path" ]; then
            unlink_directory_contents "$item" "$target_path"
        fi
    done
}

# Show status
show_status() {
    log_info "Symlink configuration status:"
    log_info "Working directory: $DOTFILES_DIR"
    echo
    
    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        if [[ "$line" =~ ^([^-]+)[[:space:]]*-\>[[:space:]]*(.+)$ ]]; then
            local package="${BASH_REMATCH[1]// /}"
            local target="${BASH_REMATCH[2]// /}"
            target="${target/#\~/$HOME}"
            
            local source_dir="$DOTFILES_DIR/$package"
            
            # Check if package exists
            if [ ! -d "$source_dir" ]; then
                echo -e "  ${RED}✗${NC} $package -> $target ${RED}(package not found)${NC}"
                continue
            fi
            
            # Check target status
            if [ -L "$target" ]; then
                local link_target=$(readlink "$target")
                if [ "$link_target" = "$source_dir" ]; then
                    echo -e "  ${GREEN}✓${NC} $package -> $target ${GREEN}(linked)${NC}"
                else
                    echo -e "  ${YELLOW}⚠${NC} $package -> $target ${YELLOW}(symlink to: $link_target)${NC}"
                fi
            elif [ -d "$target" ]; then
                # Check if contents are symlinked
                local linked_count=0
                local total_count=0
                
                count_links "$source_dir" "$target"
                
                if [ $total_count -eq 0 ]; then
                    echo -e "  ${YELLOW}⚠${NC} $package -> $target ${YELLOW}(empty package)${NC}"
                elif [ $linked_count -eq $total_count ]; then
                    echo -e "  ${GREEN}✓${NC} $package -> $target ${GREEN}(merged, $linked_count/$total_count files linked)${NC}"
                elif [ $linked_count -gt 0 ]; then
                    echo -e "  ${YELLOW}⚠${NC} $package -> $target ${YELLOW}(partial, $linked_count/$total_count files linked)${NC}"
                else
                    echo -e "  ${RED}✗${NC} $package -> $target ${RED}(not linked, target exists)${NC}"
                fi
            else
                echo -e "  ${RED}✗${NC} $package -> $target ${RED}(not linked)${NC}"
            fi
        fi
    done < "$CONFIG_FILE"
}

# Count linked files recursively
count_links() {
    local source_dir="$1"
    local target_dir="$2"
    
    [ -d "$source_dir" ] || return
    
    for item in "$source_dir"/* "$source_dir"/.[!.]* "$source_dir"/..?*; do
        [ -e "$item" ] || continue
        
        local item_name=$(basename "$item")
        local target_path="$target_dir/$item_name"
        
        ((total_count++))
        
        if [ -L "$target_path" ]; then
            local link_target=$(readlink "$target_path")
            if [ "$link_target" = "$item" ]; then
                ((linked_count++))
            fi
        elif [ -d "$item" ] && [ -d "$target_path" ]; then
            count_links "$item" "$target_path"
        fi
    done
}

# Show usage
usage() {
    cat << EOF
Usage: $(basename "$0") [COMMAND]

Commands:
    link      Create symlinks for all packages (default)
    unlink    Remove symlinks for all packages
    status    Show current status
    help      Show this help message

Configuration file: symlink.conf (in current directory)
Format: package -> target_directory

Example symlink.conf:
    # Full directory symlink (if target doesn't exist)
    nvim -> ~/.config/nvim
    
    # Merge into existing directory (if target exists)
    ideavim -> ~/
    bash -> ~/
    
    # Also works for nested paths
    tmux -> ~/.config/tmux

How it works:
    - If target doesn't exist: Symlinks entire directory
    - If target exists: Merges contents (symlinks individual files/dirs)
    - Always creates proper symlinks to your dotfiles directory
    - Never creates broken links or temp directories

Examples:
    nvim/init.lua + nvim -> ~/.config/nvim
    → If ~/.config/nvim doesn't exist: ~/.config/nvim -> ~/.dotfiles/nvim
    → If ~/.config/nvim exists: ~/.config/nvim/init.lua -> ~/.dotfiles/nvim/init.lua

EOF
}

# Main
main() {
    case "${1:-link}" in
        link|stow)
            link_packages
            log_success "Linking complete!"
            ;;
        unlink|unstow|delete)
            unlink_packages
            log_success "Unlinking complete!"
            ;;
        status)
            show_status
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            log_error "Unknown command: $1"
            usage
            exit 1
            ;;
    esac
}

main "$@"
